{"id":1855,"date":"2018-08-19T18:39:36","date_gmt":"2018-08-20T01:39:36","guid":{"rendered":"http:\/\/davidegerosa.com\/?page_id=1855"},"modified":"2020-05-24T16:59:09","modified_gmt":"2020-05-24T16:59:09","slug":"gwdet","status":"publish","type":"page","link":"https:\/\/davidegerosa.com\/gwdet\/","title":{"rendered":"gwdet: Detectability of gravitational-wave signals from compact binary coalescences"},"content":{"rendered":"\n<p>Check me out on <a href=\"https:\/\/github.com\/dgerosa\/gwdet\">github.com\/dgerosa\/gwdet<\/a>.<\/p>\n\n\n\n<p>This is a short python module to compute the probability of detecting a gravitational-wave signal from compact binaries averaging over sky-location and source inclination.<\/p>\n\n<p>The detectability function is defined by Finn and Chernoff in <a href=\"https:\/\/arxiv.org\/abs\/gr-qc\/9301003\">arxiv:9301003<\/a> as a function of the projection parameter Theta (their Eq. 3.31). Here however, we follow the notation of Dominik+ in <a href=\"https:\/\/arxiv.org\/abs\/1405.7016\">arxiv:1405.7016<\/a>, which defined w= Theta\/4 such that 0&lt;=w&lt;=1. We are interested in the cumulative distribution P(>w) of the projection parameter w (see their Eq. A.1). This gives the probabilty that an elliptically polarized gravitational-wave signal (like that of a binary) will be detected taking into account the antenna pattern of the detector and the inclination of the source (here we consider a single detector, even if in the real world we deal with networks\u2026).<\/p>\n\n<p>For a given (non-spinning) compact binary with masses m1 and m2 at redshift z, you first need to compute its signal-to-noise ratio snr_opt assuming optimal orientation and location  (i.e. the source is face on, overhead the detector). Then specify a threshold, say 8, above which you consider the signal detectable. The probabilty that a specific binary will be detected is just P(w=8\/snr_opt).<\/p>\n\n<p>Right now this code can only handle non-spinning systems. I will generalize it to spinning sources, eventually (any help is very welcome! Send a me a pull request).<\/p>\n\n<h3>Cite me...<\/h3>\n\n<p>If you use this software in a scientific publication, I kindly ask you to cite its DOI:   <a href=\"https:\/\/zenodo.org\/badge\/latestdoi\/103295136\"><img decoding=\"async\" src=\"https:\/\/zenodo.org\/badge\/103295136.svg\" alt=\"DOI\" \/><\/a><\/p>\n\n<p>This code is developed and maintained by <a href=\"https:\/\/davidegerosa.com\/\">Davide Gerosa<\/a>. To report bugs, please open an issue on GitHub. If you want to contact me, it's <code>dgerosa@caltech.edu<\/code>.<\/p>\n\n<h3>Results<\/h3>\n\n<p><code>gwdet<\/code> has been used in the following papers:<\/p>\n\n<ul>\n<li>Taylor and Gerosa (2018) <a href=\"https:\/\/arxiv.org\/abs\/1808.02491\">arXiv:1808.02491<\/a><\/li>\n<li>Gerosa et al. (2018) <a href=\"https:\/\/arxiv.org\/abs\/1808.02491\">arXiv:1808.02491<\/a><\/li>\n<\/ul>\n\n<h2>Installation and checkpoints<\/h2>\n\n<p>You can install this module using pip<\/p>\n\n<pre><code>pip install gwdet\n<\/code><\/pre>\n\n<p>Dependancies include <code>numpy<\/code>, <code>scipy<\/code>,<code>matplotlib<\/code>,<code>astropy<\/code>,<code>requests<\/code> and <code>pathos<\/code> will be installed automatically if not present. The LIGO software <code>lal<\/code> and <code>pycbc<\/code> are needed to use this code with values other than the default ones (see <a href=\"https:\/\/davidegerosa.com\/installlal\/\">here<\/a> for a short guide I wrote).<\/p>\n\n<p>If you limit yourself to the default values, I provide some checkpoints files which let you use the code without installing any LIGO software. In any case, even if you have <code>lal<\/code>, dowloading these checkpoints will save you a lot of computational time. When you use the code with defaults parameters for the first time, a message like the following will be printed out:<\/p>\n\n<pre><code>[gwdet] You are using defaults values. You can download this interpolant. Use:\n    curl ....\n<\/code><\/pre>\n\n<p>To download the checkpoints, just execute that whole command starting with <code>curl<\/code>.  There are two checkpoint files of ~5MB and ~200MB. Note that these files <em>will not be removed<\/em>  if you uninstall the module via <code>pip uninstall<\/code> , you will need to remove them manually. If you install <code>gwdet<\/code> in a virtual environment, these checkpoint files will live in the environment directory and will be removed when\/if you delete the environment.<\/p>\n\n<h2>Usage<\/h2>\n\n<p>This code has two classes only, <code>averageangles<\/code> and <code>detectability<\/code>. You first need to create an instance of each class and then use them.<\/p>\n\n<p>The default usage is<\/p>\n\n<pre><code>p=gwdet.averageangles()\nw=0.5 # Projection parameter\nprint(p(w)) # Fraction of detectabile sources\n\np=gwdet.detectability()\nm1=10. # Component mass in Msun\nm2=10. # Component mass in Msun\nz=0.1  # Redshift\nprint(p(m1,m2,z))  # Fraction of detectabile sources\n<\/code><\/pre>\n\n<h3>averageangles<\/h3>\n\n<p>Compute the detection probability, averaged over all angles (sky location, polarization, inclination, etc), as a function of the projection parameter w.<\/p>\n\n<pre><code>p = averageangles(  directory=os.path.dirname(__file__), \n                binfile=None, \n                mcn=int(1e8), \n                mcbins=int(1e5) )\n\ndet = p(w) # with 0&lt;=w&lt;=1\n<\/code><\/pre>\n\n<h5><strong>Parameters<\/strong>:<\/h5>\n\n<ul>\n<li><code>directory<\/code>: where checkpoints are stored (default is the module location)<\/li>\n<li><code>binfile<\/code>: checkpoint file (if <code>None<\/code> computed from other kwargs)<\/li>\n<li><code>mcn<\/code>: resolution parameter (number of Monte Carlo samples)<\/li>\n<li><code>mcbins<\/code>: resolution parameter (number of interpolated bins)<\/li>\n<li><code>w<\/code>: projection parameter 0&lt;=w&lt;=1, see arxiv:1405.7016 (can be float or array)<\/li>\n<\/ul>\n\n<h5><strong>Returns<\/strong>:<\/h5>\n\n<ul>\n<li><code>det<\/code>: GW detectability (float or array)<\/li>\n<\/ul>\n\n<h3>detectability<\/h3>\n\n<p>Compute the detection probability of a non-spinning compact binary.<\/p>\n\n<pre><code>p = detectability(  directory=os.path.dirname(__file__), \n                binfile=None, \n                binfilepdet=None,\n                approximant='IMRPhenomD',\n                psd='aLIGOZeroDetHighPower',\n                psd_from_path=False,\n                psd_path=None,\n                is_asd_file=None,\n                flow=10.,\n                deltaf=1.\/40.,\n                snrthreshold=8.,\n                massmin=1.,\n                massmax=100.,\n                zmin=1e-4,\n                zmax=2.2,\n                mc1d=int(200),\n                mcn=int(1e8),\n                mcbins=int(1e5), \n                parallel=True,\n                screen=False)\n\ndet = p(m1,m2,z)\n<\/code><\/pre>\n\n<h5>Parameters:<\/h5>\n\n<ul>\n<li><code>directory<\/code>: where checkpoints are stored (default is the module location)<\/li>\n<li><code>binfile<\/code>: checkpoint file (if None computed from other kwargs)<\/li>\n<li><code>binfilepdet<\/code>: checkpoint file (if None computed from other kwargs)<\/li>\n<li><code>approximant<\/code>: waveform appriximant used to compute SNRs. Available list: <code>pycbc.waveform.waveform.print_fd_approximants()<\/code><\/li>\n<li><code>psd<\/code>: power spectral density used to compute SNRs. Available list: <code>pycbc.psd.analytical.get_lalsim_psd_list()<\/code><\/li>\n<li><code>psd_from_path<\/code>: load psd using <code>pycbc.psd.from_txt<\/code> (default False)<\/li>\n<li><code>psd_path<\/code>: power spectral density used to compute SNRs. Provide path to <code>.txt<\/code> file (default None)<\/li>\n<li><code>is_asd_file<\/code>: check whether the <code>txt<\/code> file contains amplitude or power spectral density (default True)<\/li>\n<li><code>flow<\/code>: starting frequency in SNR calculations<\/li>\n<li><code>deltaf<\/code>: resolution parameter (frequency sampling)<\/li>\n<li><code>snrthreshold<\/code>: minimum detectable signal<\/li>\n<li><code>massmin<\/code>,<code>massax<\/code>: limits on the component masses in Msun. Interpolated inside, extrapolated outside<\/li>\n<li><code>zmin<\/code>,<code>zmax<\/code>: limits on the redshift. Interpolated inside, extrapolated outside<\/li>\n<li><code>mc1d<\/code>: resolution parameter (number of grid point per dimension)<\/li>\n<li><code>mcn<\/code>: resolution parameter (number of Monte Carlo samples)<\/li>\n<li><code>mcbins<\/code>: resolution parameter (number of interpolated bins)<\/li>\n<li><code>parallel<\/code>: use parallel jobs on all CPUs available<\/li>\n<li><code>screen<\/code>: debug option, prints all SNRs computed<\/li>\n<li><code>m1<\/code>: component mass in Msun (can be float or array)<\/li>\n<li><code>m2<\/code>: component mass in Msun (can be float or array)<\/li>\n<li><code>z<\/code>: redshift (can be float or array)<\/li>\n<\/ul>\n\n<h5>Returns:<\/h5>\n\n<ul>\n<li><code>det<\/code>: GW detectability (float or array)<\/li>\n<\/ul>\n\n<h2>Checks and performance<\/h2>\n\n<p>Here I first compare the performance of the P(w) interpolator implemented in <code>averageangles<\/code> against public data from <a href=\"http:\/\/www.phy.olemiss.edu\/~berti\/research\/\">Emanuele Berti's website<\/a>. The agreement is excellent and the residuals are just numerical noise. This plot can be generated with:<\/p>\n\n<pre><code>gwdet.compare_Pw()\n<\/code><\/pre>\n\n<p><img decoding=\"async\" src=\"https:\/\/user-images.githubusercontent.com\/7237041\/30345791-54f23092-97bb-11e7-8327-1a6531a1437a.png\" alt=\"compare_pw\" \/><\/p>\n\n<p>Seconly, I compare the perfomance of the P(m1,m2,z) interpolator of <code>detectability<\/code> against 1000 bruce force SNR computations from <code>lal<\/code>. Altough occasional mismathces of 3% are found, the median residuals are as small as ~1e-5. This plot can be generated with:<\/p>\n\n<pre><code>gwdet.compare_Psnr()\n<\/code><\/pre>\n\n<p><img decoding=\"async\" src=\"https:\/\/user-images.githubusercontent.com\/7237041\/30341935-c3bd36e8-97ac-11e7-947d-ac06dae3bedb.png\" alt=\"compare_psnr\" \/><\/p>\n\n\n\n\n<p><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Check me out on github.com\/dgerosa\/gwdet.<\/p>\n","protected":false},"author":2,"featured_media":2065,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"_coblocks_attr":"","_coblocks_dimensions":"","_coblocks_responsive_height":"","_coblocks_accordion_ie_support":"","_monsterinsights_skip_tracking":false,"_monsterinsights_sitenote_active":false,"_monsterinsights_sitenote_note":"","_monsterinsights_sitenote_category":0,"footnotes":""},"class_list":["post-1855","page","type-page","status-publish","has-post-thumbnail","hentry"],"jetpack_sharing_enabled":true,"_links":{"self":[{"href":"https:\/\/davidegerosa.com\/wp-json\/wp\/v2\/pages\/1855"}],"collection":[{"href":"https:\/\/davidegerosa.com\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"https:\/\/davidegerosa.com\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"https:\/\/davidegerosa.com\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"https:\/\/davidegerosa.com\/wp-json\/wp\/v2\/comments?post=1855"}],"version-history":[{"count":1,"href":"https:\/\/davidegerosa.com\/wp-json\/wp\/v2\/pages\/1855\/revisions"}],"predecessor-version":[{"id":3410,"href":"https:\/\/davidegerosa.com\/wp-json\/wp\/v2\/pages\/1855\/revisions\/3410"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/davidegerosa.com\/wp-json\/wp\/v2\/media\/2065"}],"wp:attachment":[{"href":"https:\/\/davidegerosa.com\/wp-json\/wp\/v2\/media?parent=1855"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}